\hypertarget{classnlohmann_1_1basic__json_1_1binary__reader}{}\doxysection{nlohmann\+::basic\+\_\+json$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader Class Reference}
\label{classnlohmann_1_1basic__json_1_1binary__reader}\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}


deserialization of C\+B\+OR and Message\+Pack values  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a68d376356bb3ef5a7059584eb0fec847}{binary\+\_\+reader}} (\mbox{\hyperlink{classnlohmann_1_1basic__json_abcea1aaef7ef968e0f89a45722ae63b4}{input\+\_\+adapter\+\_\+t}} adapter)
\begin{DoxyCompactList}\small\item\em create a binary reader \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a8dfb5cc53ac25ac24ad96c6b13f0e56b}{parse\+\_\+cbor}} (const bool get\+\_\+char=true)
\begin{DoxyCompactList}\small\item\em create a J\+S\+ON value from C\+B\+OR input \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a8800236e50b397f1b7dac9899572657f}{parse\+\_\+msgpack}} ()
\begin{DoxyCompactList}\small\item\em create a J\+S\+ON value from Message\+Pack input \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a3363f49b1d6e4320c3b0582d82a60def}{little\+\_\+endianess}} () noexcept
\begin{DoxyCompactList}\small\item\em determine system byte order \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_ad2bc5e4766b108c02de4062fd7ed56d2}{get}} ()
\begin{DoxyCompactList}\small\item\em get next character from the input \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a1a4ec8f97105c00f405288d7283a3070}\label{classnlohmann_1_1basic__json_1_1binary__reader_a1a4ec8f97105c00f405288d7283a3070}} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries get\+\_\+number} ()
\item 
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a1bd3721cf007540405163cd63e333898}{get\+\_\+string}} (const size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em create a string by reading characters from the input \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a8b4afd3e41c6ac107fbae7ae4fe65b5e}{get\+\_\+cbor\+\_\+string}} ()
\begin{DoxyCompactList}\small\item\em reads a C\+B\+OR string \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a6973873b7ad84fc11b8cda23dafd4623}{get\+\_\+msgpack\+\_\+string}} ()
\begin{DoxyCompactList}\small\item\em reads a Message\+Pack string \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a3450f998464817bde2fe5e20f846d9fc}{check\+\_\+eof}} () const
\begin{DoxyCompactList}\small\item\em check if input ended \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a408f266a46b2045cece9d654e39827ee}\label{classnlohmann_1_1basic__json_1_1binary__reader_a408f266a46b2045cece9d654e39827ee}} 
\mbox{\hyperlink{classnlohmann_1_1basic__json_abcea1aaef7ef968e0f89a45722ae63b4}{input\+\_\+adapter\+\_\+t}} \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a408f266a46b2045cece9d654e39827ee}{ia}} = nullptr
\begin{DoxyCompactList}\small\item\em input adapter \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_ae3939cb2bb3599ac8e689e453588d30b}\label{classnlohmann_1_1basic__json_1_1binary__reader_ae3939cb2bb3599ac8e689e453588d30b}} 
int \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_ae3939cb2bb3599ac8e689e453588d30b}{current}} = std\+::char\+\_\+traits$<$char$>$\+::eof()
\begin{DoxyCompactList}\small\item\em the current character \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a728cee17915ea874abb2aaa0c6b8ffaf}\label{classnlohmann_1_1basic__json_1_1binary__reader_a728cee17915ea874abb2aaa0c6b8ffaf}} 
size\+\_\+t \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a728cee17915ea874abb2aaa0c6b8ffaf}{chars\+\_\+read}} = 0
\begin{DoxyCompactList}\small\item\em the number of characters read \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a0ac1ead568da8a9495cdc983ea9b5943}\label{classnlohmann_1_1basic__json_1_1binary__reader_a0ac1ead568da8a9495cdc983ea9b5943}} 
const bool \mbox{\hyperlink{classnlohmann_1_1basic__json_1_1binary__reader_a0ac1ead568da8a9495cdc983ea9b5943}{is\+\_\+little\+\_\+endian}} = true
\begin{DoxyCompactList}\small\item\em whether we can assume little endianess \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type = std\+::string, class Boolean\+Type = bool, class Number\+Integer\+Type = std\+::int64\+\_\+t, class Number\+Unsigned\+Type = std\+::uint64\+\_\+t, class Number\+Float\+Type = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$\newline
class nlohmann\+::basic\+\_\+json$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader}

deserialization of C\+B\+OR and Message\+Pack values 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a68d376356bb3ef5a7059584eb0fec847}\label{classnlohmann_1_1basic__json_1_1binary__reader_a68d376356bb3ef5a7059584eb0fec847}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!binary\_reader@{binary\_reader}}
\index{binary\_reader@{binary\_reader}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{binary\_reader()}{binary\_reader()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::binary\+\_\+reader (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classnlohmann_1_1basic__json_abcea1aaef7ef968e0f89a45722ae63b4}{input\+\_\+adapter\+\_\+t}}}]{adapter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



create a binary reader 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em adapter} & input adapter to read from \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a3450f998464817bde2fe5e20f846d9fc}\label{classnlohmann_1_1basic__json_1_1binary__reader_a3450f998464817bde2fe5e20f846d9fc}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!check\_eof@{check\_eof}}
\index{check\_eof@{check\_eof}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{check\_eof()}{check\_eof()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
void \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::check\+\_\+eof (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



check if input ended 


\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input ended \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_ad2bc5e4766b108c02de4062fd7ed56d2}\label{classnlohmann_1_1basic__json_1_1binary__reader_ad2bc5e4766b108c02de4062fd7ed56d2}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!get@{get}}
\index{get@{get}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
int \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::get (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



get next character from the input 

This function provides the interface to the used input adapter. It does not throw in case the input reached E\+OF, but returns {\ttfamily std\+::char\+\_\+traits$<$char$>$\+::eof()} in that case.

\begin{DoxyReturn}{Returns}
character read from the input 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a8b4afd3e41c6ac107fbae7ae4fe65b5e}\label{classnlohmann_1_1basic__json_1_1binary__reader_a8b4afd3e41c6ac107fbae7ae4fe65b5e}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!get\_cbor\_string@{get\_cbor\_string}}
\index{get\_cbor\_string@{get\_cbor\_string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{get\_cbor\_string()}{get\_cbor\_string()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::get\+\_\+cbor\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



reads a C\+B\+OR string 

This function first reads starting bytes to determine the expected string length and then copies this number of bytes into a string. Additionally, C\+B\+OR\textquotesingle{}s strings with indefinite lengths are supported.

\begin{DoxyReturn}{Returns}
string
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input ended \\
\hline
{\em parse\+\_\+error.\+113} & if an unexpexted byte is read \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a6973873b7ad84fc11b8cda23dafd4623}\label{classnlohmann_1_1basic__json_1_1binary__reader_a6973873b7ad84fc11b8cda23dafd4623}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!get\_msgpack\_string@{get\_msgpack\_string}}
\index{get\_msgpack\_string@{get\_msgpack\_string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{get\_msgpack\_string()}{get\_msgpack\_string()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::get\+\_\+msgpack\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



reads a Message\+Pack string 

This function first reads starting bytes to determine the expected string length and then copies this number of bytes into a string.

\begin{DoxyReturn}{Returns}
string
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input ended \\
\hline
{\em parse\+\_\+error.\+113} & if an unexpexted byte is read \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a1bd3721cf007540405163cd63e333898}\label{classnlohmann_1_1basic__json_1_1binary__reader_a1bd3721cf007540405163cd63e333898}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!get\_string@{get\_string}}
\index{get\_string@{get\_string}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{get\_string()}{get\_string()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
std\+::string \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::get\+\_\+string (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



create a string by reading characters from the input 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em len} & number of bytes to read\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string created by reading {\itshape len} bytes
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input has less than {\itshape len} bytes \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a3363f49b1d6e4320c3b0582d82a60def}\label{classnlohmann_1_1basic__json_1_1binary__reader_a3363f49b1d6e4320c3b0582d82a60def}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!little\_endianess@{little\_endianess}}
\index{little\_endianess@{little\_endianess}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{little\_endianess()}{little\_endianess()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
static bool \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::little\+\_\+endianess (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [noexcept]}}



determine system byte order 

\begin{DoxyReturn}{Returns}
true iff system\textquotesingle{}s byte order is little endian
\end{DoxyReturn}
\begin{DoxyNote}{Note}
from \href{http://stackoverflow.com/a/1001328/266378}{\texttt{ http\+://stackoverflow.\+com/a/1001328/266378}} 
\end{DoxyNote}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a8dfb5cc53ac25ac24ad96c6b13f0e56b}\label{classnlohmann_1_1basic__json_1_1binary__reader_a8dfb5cc53ac25ac24ad96c6b13f0e56b}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!parse\_cbor@{parse\_cbor}}
\index{parse\_cbor@{parse\_cbor}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{parse\_cbor()}{parse\_cbor()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::parse\+\_\+cbor (\begin{DoxyParamCaption}\item[{const bool}]{get\+\_\+char = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



create a J\+S\+ON value from C\+B\+OR input 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em get\+\_\+char} & whether a new character should be retrieved from the input (true, default) or whether the last read character should be considered instead\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
J\+S\+ON value created from C\+B\+OR input
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input ended unexpectedly \\
\hline
{\em parse\+\_\+error.\+112} & if unsupported byte was read \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classnlohmann_1_1basic__json_1_1binary__reader_a8800236e50b397f1b7dac9899572657f}\label{classnlohmann_1_1basic__json_1_1binary__reader_a8800236e50b397f1b7dac9899572657f}} 
\index{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}!parse\_msgpack@{parse\_msgpack}}
\index{parse\_msgpack@{parse\_msgpack}!nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader@{nlohmann::basic\_json$<$ ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer $>$::binary\_reader}}
\doxysubsubsection{\texorpdfstring{parse\_msgpack()}{parse\_msgpack()}}
{\footnotesize\ttfamily template$<$template$<$ typename U, typename V, typename... Args $>$ class Object\+Type = std\+::map, template$<$ typename U, typename... Args $>$ class Array\+Type = std\+::vector, class String\+Type  = std\+::string, class Boolean\+Type  = bool, class Number\+Integer\+Type  = std\+::int64\+\_\+t, class Number\+Unsigned\+Type  = std\+::uint64\+\_\+t, class Number\+Float\+Type  = double, template$<$ typename U $>$ class Allocator\+Type = std\+::allocator, template$<$ typename T, typename S\+F\+I\+N\+A\+E=void $>$ class J\+S\+O\+N\+Serializer = adl\+\_\+serializer$>$ \\
\mbox{\hyperlink{classnlohmann_1_1basic__json}{basic\+\_\+json}} \mbox{\hyperlink{classnlohmann_1_1basic__json}{nlohmann\+::basic\+\_\+json}}$<$ Object\+Type, Array\+Type, String\+Type, Boolean\+Type, Number\+Integer\+Type, Number\+Unsigned\+Type, Number\+Float\+Type, Allocator\+Type, J\+S\+O\+N\+Serializer $>$\+::binary\+\_\+reader\+::parse\+\_\+msgpack (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



create a J\+S\+ON value from Message\+Pack input 

\begin{DoxyReturn}{Returns}
J\+S\+ON value created from Message\+Pack input
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em parse\+\_\+error.\+110} & if input ended unexpectedly \\
\hline
{\em parse\+\_\+error.\+112} & if unsupported byte was read \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
lib/include/json.\+hpp\end{DoxyCompactItemize}
